
# Imports ----------------------------------------------------------------------
import os
from shutil import which
from typing import List, Union
import tempfile
import uuid
import subprocess

# Main -------------------------------------------------------------------------
def run_plmc_weights(
        msa_path: str,
        weights_path: Union[None, str]=None,
        reuse_existing_output: bool=False,
        n_cpu: int=4,
        log_debug: bool=False,
        plmc_path: Union[None, str]=None,
    ) -> List[float]:
    """Run PLMC to get weights for MSA [msa_path]: Saves weights file at [weights_path] and returns list of weights.
    
    Usage: seq_weights = run_plmc_weights('./msa/1acb_A.fasta')

    Args:
        msa_path (str): path to MSA file in '.fasta' format
        weights_path (str, default=None): output path for weights generated by plmc
        reuse_existing_output (bool, default=False): set True to re-use weights file if it already exists
        n_cpu (int, default=4): number of cores used by plmc
        log_debug (bool, default=False): set True to log plmc execution
        plmc_path (str, default=None): overwrite plmc executable default path list

    output: weights list (List[float])
    """

    # Hard-coded plmc candidate paths
    PLMC_PATH_LIST = [
        "/home/Softs/plmc/bin/plmc",                            # Santorin and Nautilus
    ]

    # Check input paths errors
    assert os.path.isfile(msa_path), f"ERROR in run_plmc_weights(): msa_path='{msa_path}' files does not exists."
    assert msa_path.endswith(".fasta"), f"ERROR in run_plmc_weights(): msa_path='{msa_path}' should be a '.fasta' file."
    if weights_path is not None:
        assert os.path.isdir(os.path.dirname(weights_path)), f"ERROR in run_plmc_weights(): direcotry of weights_path='{weights_path}' does not exists."

    # Parse output file if it already exists
    if reuse_existing_output and weights_path is not None and os.path.isfile(weights_path):
        return parse_plmc_weights(weights_path)

    # Find plmc executable path
    if plmc_path is not None: # Overwrite plmc path by user's input
         PLMC_PATH_LIST = [plmc_path]
    plmc_error_message = f"""ERROR in run_plmc_weights(): no path found for software 'plmc' executable.
    -> Please install the 'plmc' software (https://github.com/debbiemarkslab/plmc).
    -> Then, specify the path to its executable file as input or add 'plmc' executable to global PATH-variable.
    """
    plmc_path = find_software_executable(PLMC_PATH_LIST, "plmc", "plmc", plmc_error_message)

    # Assign temporary weights path
    temporary_weights = False
    if weights_path is None:
        temporary_weights = True
        msa_name = os.path.basename(msa_path).removesuffix(".fasta")
        msa_name_tmp = f"{msa_name}_{str(uuid.uuid1())[0:8]}"
        weights_path = os.path.join(tempfile.gettempdir(), f"{msa_name_tmp}-weights.txt")

    # Define plmc command
    weights_path = os.path.abspath(weights_path)
    msa_path = os.path.abspath(msa_path)
    command = f"{plmc_path} --fast --maxiter 0 --ncores {n_cpu} --save-weights {weights_path} {msa_path}"

    # Run the command and capture the output
    if log_debug:
        print(f"Run plmc command: \n $ {command}")
    process = subprocess.run(command, shell=True, check=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

    # Log plmc output
    if log_debug:
        for log_line in process.stdout.split("\n"): print(log_line)

    # Errors managements
    if process.returncode != 0:
        for log_line in process.stdout.split("\n"): print(log_line)
        raise ValueError(f"ERROR in run_plmc_weights(): execution of plmc failed on '{msa_path}': $ \n{command}")
    if not os.path.isfile(weights_path):
        for log_line in process.stdout.split("\n"): print(log_line)
        raise ValueError(f"ERROR in run_plmc_weights(): no weights file generated by plmc run on '{msa_path}'.")
    
    # Parse
    weights = parse_plmc_weights(weights_path)

    # Remove output weights file if required
    if temporary_weights:
        if os.path.isfile(weights_path): os.remove(weights_path)

    return weights


def parse_plmc_weights(weights_path: str) -> List[float]:
    """Parse plmc output weights file and returns weights list."""

    # Guardians
    assert os.path.isfile(weights_path), f"ERROR in parse_plmc_weights(): weights_path='{weights_path}' file does not exists."

    # Parse
    with open(weights_path) as fs:
        return [float(line) for line in fs.readlines()]
    
def find_software_executable(
        path_list: List[str],
        software_name: str,
        software_executable_filename: Union[None, str]=None,
        error_log: Union[None, str]=None
    ) -> str:
    """Find an existing executable path to a software and throw error if not found."""

    # Try to find existing path among path_list
    executable_path = None
    for candidate_path in path_list:
        if os.path.isfile(candidate_path):
            executable_path = candidate_path
            break

    # Try to find executable in global path variable
    if executable_path is None:
        if which(software_executable_filename) is not None:
            executable_path = software_executable_filename

    # Print not-found software error message and throw error
    if executable_path is None:
        error_message = f"ERROR in find_software_executable(): No executable file found for '{software_name}'."
        for candidate_path in path_list:
            error_message += f"\n    * Executable file not found at '{candidate_path}'."
        if software_executable_filename is not None:
            error_message += f"\n    * Global PATH-variable not found at '{candidate_path}'."
        error_message += "\n" + error_log
        raise ValueError(error_message)

    # Return founded path
    return executable_path